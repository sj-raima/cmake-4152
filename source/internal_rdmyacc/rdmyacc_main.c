/* ----------------------------------------------------------------------------
 * Raima Database Manager
 *
 * Copyright (c) 2010 Raima Inc.,  All rights reserved.
 *
 * Use of this software, whether in source code format, or in executable,
 * binary object code form, is governed by the Raima LICENSE which
 * is fully described in the LICENSE.TXT file, included within this
 * distribution of files.
 * ----------------------------------------------------------------------------
 */
#include "dtxtrn.h"
#include <ctype.h>

/*lint -e801 */

#define RDMYACC_EMPTY 1
#define RDMYACC_WHOKNOWS 0
#define RDMYACC_OK 1

#define a amem
#define pa indgo
#define greed tystate
#define yypact temp1

#define NOMORE (-1000)

/*lint -save -e956 */
extern char startnm[];
extern char startnmuc[];

int32_t nlset = 0;   /* next lookahead set index */
int32_t nprod = 1;   /* number of productions */
int32_t nstate = 0;  /* number of states */
int32_t nerrors = 0; /* number of errors */
int32_t ntokens = 0;
int32_t nnonter = -1;
int32_t zzexcp = 0;
int32_t zzgoent = 0;
int32_t zzacent = 0;
int32_t zzclose = 0;
int32_t zzgobest = 0;
int32_t zzsrconf = 0;
int32_t zzrrconf = 0;
const intptr_t *zzmemsz = mem0;
intptr_t mem0[MEMSIZE];   /* production storage */
intptr_t defact[NSTATES]; /* the default actions of states */
intptr_t levprd[NPROD];   /* precedence levels for the productions */
int32_t toklev[NTERMS];
int32_t tstates[NTERMS];    /* states generated by terminal gotos */
int32_t ntstates[NNONTERM]; /* states generated by nonterminal gotos */
int32_t mstates[NSTATES];   /* chain of overflows of term/nonterm generation
                             lists  */
intptr_t amem[ACTSIZE];     /* action table storage */
intptr_t temp1[TEMPSIZE];   /* temporary storage, indexed by terms + ntokens
                             or states */
intptr_t *prdptr[NPROD];    /* pointers to descriptions of productions */
intptr_t *mem = mem0;
const intptr_t *memp = amem; /* next free action table position */

struct toksymb tokset[NTERMS];
struct ntsymb nontrst[NNONTERM];

struct wset wsets[WSETSIZE];
const struct wset *zzcwp = wsets;

static struct wset *cwp;

/* lookahead computations */
static struct looksets clset; /* temporary storage for
                               lookahead computations */
static struct looksets lkst[LSETSIZE];
static struct looksets *pfirst[NNONTERM + 2]; /* vector of pointers to first
                                               sets for each nonterminal */

/*lint -esym(843,adb,yypgo) -esym(844,maxa) */
static int32_t adb = 0;
static int32_t nolook = 0;  /* flag to suppress lookahead computations */
static intptr_t maxoff = 0; /* maximum offset into a array */
static intptr_t maxspr = 0; /* maximum spread of any entry */
static intptr_t lastred;    /* the number of the last reduction of a state */
static int32_t tbitset;     /* size of lookahead sets */
static intptr_t *maxa;
static intptr_t *pgo;
static intptr_t *pmem = mem0;
static int32_t *yypgo = &nontrst[0].tvalue;
static intptr_t *ggreed;
static intptr_t **pres[NNONTERM + 2]; /* vector of pointers to productions
                                       yielding each nonterminal */
static intptr_t pempty[NNONTERM + 1]; /* vector of nonterminals nontrivially
                                       deriving e */
static char sarr[ISIZE];

/* state information */
static struct item *pstate[NSTATES + 2]; /* pointers to the descriptions of
                                          the states */
static intptr_t tystate[NSTATES];        /* contains type information about
                                          the states */
static intptr_t indgo[NSTATES];          /* index to the stored goto table */
/*lint -restore */

static int32_t apack (intptr_t *, int32_t);
static void arout (const char *, const intptr_t *, int32_t);
static void callopt (void);
static void cempty (void);
static char *chcopy (char *, const char *);
static void closure (int32_t);
static void cpfir (void);
static void cpres (void);
static struct looksets *flset (const struct looksets *);
static void gin (int32_t);
static void go2gen (int32_t);
static void go2out (void);
static int32_t gtnm (void);
static void hideprod (void);
static int32_t nxti (void);
static void osummary (void);
static void output (void);
static void precftn (intptr_t, intptr_t, int32_t);
#if defined(debug)
static void prlook (struct looksets *);
#endif
static void putitem (intptr_t *, const struct looksets *);
static int32_t setunion (intptr_t *, const intptr_t *); /*lint -esym(534,setunion */
static void stagen (void);
static int32_t state (intptr_t); /*lint -esym(534,state) */
static void stin (int32_t);
static const char *symnam (intptr_t);
static void wract (int32_t);
static char *writem (const intptr_t *);
static void wrstate (int32_t);

/* pack state i from temp1 into amem */
static int32_t apack (intptr_t *p, int32_t n)
{
    int32_t off;
    intptr_t *pp;
    intptr_t *qq;
    intptr_t *rr;
    const intptr_t *q;
    const intptr_t *r;

    /* we don't need to worry about checking because we we will only look
     entries known to be there... */

    /* eliminate leading and trailing 0's */
    q = p + n;
    for (pp = p, off = 0; *pp == 0 && pp <= q; ++pp, --off) /* VOID */
        ;

    if (pp > q)
        return 0; /* no actions */

    p = pp;

    /* now, find a place for the elements from p to q, inclusive */
    r = &amem[ACTSIZE - 1];
    for (rr = amem; rr <= r; ++rr, ++off)
    {
        /* try rr */
        for (qq = rr, pp = p; pp <= q; ++pp, ++qq)
        {
            if (*pp != 0 && *pp != *qq && *qq != 0)
                break;
        }

        if (pp <= q)
            continue;

            /* we have found an acceptable k */
#if defined(debug)
        if (foutput != NULL)
            yprintf (foutput, "off = %d, k = %d\n", off, rr - amem);
#endif

        for (qq = rr, pp = p; pp <= q; ++pp, ++qq)
        {
            if (*pp)
            {
                if (qq > r)
                    error ("action table overflow", NULL);

                if (qq > memp)
                    memp = qq;

                *qq = *pp;
            }
        }

#if defined(debug)
        if (foutput != NULL)
        {
            for (pp = amem; pp <= memp; pp += 10)
            {
                yprintf (foutput, "\t");
                for (qq = pp; qq <= pp + 9; ++qq)
                    yprintf (foutput, "%d ", *qq);

                yprintf (foutput, "\n");
            }
        }
#endif

        return off;
    }

    error ("no space in action table", NULL);

    /* We cannot reach here, but just to remove compiler warnings... */
    return 0; /*lint !e527 */
}

static void arout (const char *s, const intptr_t *v, int32_t n)
{
    int32_t i;

    yprintf (ftable, "static const int16_t %s_%s[] =\n{", s, startnm);
    for (i = 0; i < n;)
    {
        if (i % 10 == 0)
            yprintf (ftable, "\n\t");

        yprintf (ftable, "%d", (int32_t) v[i]);
        if (++i == n)
            yprintf (ftable, "\n};\n\n");
        else
            yprintf (ftable, ", ");
    }
}

static void callopt (void)
{
    int32_t i;
    intptr_t j;
    intptr_t k;
    const intptr_t *p;
    const intptr_t *q;

    /* read the arrays from tempfile and set parameters */
    finput = yfopen (TEMPNAME, "r");
    if (finput == NULL)
    {
        error ("optimizer cannot open tempfile", NULL);
    }

    pgo[0] = 0;
    yypact[0] = 0;
    nstate = 0;
    nnonter = 0;
    for (;;)
    {
        switch (gtnm ())
        {
            case '\n':
                yypact[++nstate] = (int32_t) ((--pmem) - mem0); /*lint -fallthrough */

            case ',':
                continue;

            case '$':
                break;

            default:
                error ("bad tempfile", NULL);
        }

        break;
    }

    yypact[nstate] = yypgo[0] = (int32_t) ((--pmem) - mem0);

    for (;;)
    {
        switch (gtnm ())
        {
            case '\n':
                yypgo[++nnonter] = (int32_t) (pmem - mem0);
                /*lint -fallthrough */
            case '\r':
            case ',':
                continue;

            case -1: /* EOF */
                break;

            default:
                error ("bad tempfile", NULL);
        }

        break;
    }

    yypgo[nnonter--] = (int32_t) ((--pmem) - mem0);
    for (i = 0; i < nstate; ++i)
    {
        k = 32000;
        j = 0;
        q = mem0 + yypact[i + 1];
        for (p = mem0 + yypact[i]; p < q; p += 2)
        {
            if (*p > j)
                j = *p;

            if (*p < k)
                k = *p;
        }

        if (k <= j)
        {
            /* nontrivial situation */
            /* temporarily, kill this for compatibility j -= k;  j is now the
             range */
            if (k > maxoff)
                maxoff = k;
        }

        greed[i] = (yypact[i + 1] - yypact[i]) + 2 * j;
        if (j > maxspr)
            maxspr = j;
    }

    /* initialize ggreed table */
    for (i = 1; i <= nnonter; ++i)
    {
        ggreed[i] = 1;
        j = 0;
        /* minimum entry index is always 0 */
        q = mem0 + yypgo[i + 1] - 1;
        for (p = mem0 + yypgo[i]; p < q; p += 2)
        {
            ggreed[i] += 2;
            if (*p > j)
                j = *p;
        }

        ggreed[i] = ggreed[i] + 2 * j;
        if (j > maxoff)
            maxoff = j;
    }

    /* now, prepare to put the shift actions into the a array */
    for (i = 0; i < ACTSIZE; ++i)
        a[i] = 0;

    maxa = a;

    for (i = 0; i < nstate; ++i)
    {
        if (greed[i] == 0 && adb > 1)
            yprintf (ftable, "State %d: null\n", i);

        pa[i] = YYFLAG1;
    }

    while ((i = nxti ()) != NOMORE)
    {
        if (i >= 0)
            stin (i);
        else
            gin (-i);
    }

    if (adb > 2)
    {
        /* print a array */
        for (p = a; p <= maxa; p += 10)
        {
            yprintf (ftable, "%4d  ", p - a);
            for (i = 0; i < 10; ++i)
                yprintf (ftable, "%4d  ", p[i]);

            yprintf (ftable, "\n");
        }
    }

    /* write out the optimized parser */
    yprintf (ftable, "#define YYLAST_%s %d\n\n", startnmuc, (maxa - a) + 1);

    arout ("yyact", a, (int32_t) (maxa - a) + 1);
    arout ("yypact", pa, nstate);
    arout ("yypgo", pgo, nnonter + 1);

    osummary ();

    fclose (finput);
    ZAPFILE (TEMPNAME);
}

static void cempty (void)
{
    /* mark nonterminals which derive the empty string */
    /* also, look for nonterminals which don't derive any token strings */

    int32_t i;
    const intptr_t *p;

    /* first, use the array pempty to detect productions that can never be
     reduced */
    /* set pempty to WHONOWS */
    aryfil (pempty, nnonter + 1, RDMYACC_WHOKNOWS);

    /* now, look at productions, marking nonterminals which derive something */
more:
    PLOOP (0, i)
    {
        if (pempty[*prdptr[i] - NTBASE])
            continue;

        for (p = prdptr[i] + 1; *p >= 0; ++p)
        {
            if (*p >= NTBASE && pempty[*p - NTBASE] == RDMYACC_WHOKNOWS)
                break;
        }

        if (*p < 0)
        {
            /* production can be derived */
            pempty[*prdptr[i] - NTBASE] = RDMYACC_OK;
            goto more;
        }
    }

    /* now, look at the nonterminals, to see if they are all RDMYACC_OK */

    NTLOOP (i)
    {
        /* the added production rises or falls as the start symbol ... */
        if (i == 0)
            continue;

        if (pempty[i] != RDMYACC_OK)
        {
            warn ("nonterminal %s never derives any token string", nontrst[i].name);
        }
    }

    if (nerrors)
    {
        summary ();
        exit (EX_ERR);
    }

    /* now, compute the pempty array, to see which nonterminals derive the
     empty string */

    /* set pempty to RDMYACC_WHOKNOWS */

    aryfil (pempty, nnonter + 1, RDMYACC_WHOKNOWS);
    /* loop as long as we keep finding empty nonterminals */

again:
    PLOOP (1, i)
    {
        if (pempty[*prdptr[i] - NTBASE] == RDMYACC_WHOKNOWS)
        {
            /* not known to be empty */
            for (p = prdptr[i] + 1; *p >= NTBASE && pempty[*p - NTBASE] == RDMYACC_EMPTY; ++p)
                ;

            if (*p < 0)
            {
                /* we have a nontrivially empty nonterminal */
                pempty[*prdptr[i] - NTBASE] = RDMYACC_EMPTY;
                goto again; /* got one ... try for another */
            }
        }
    }
}

static char *chcopy (char *p, const char *q)
{
    /* copies string q into p, returning next free char ptr */
    while ((*p = *q++) != '\0')
        ++p;

    return p;
}

static void closure (int32_t i)
{
    /* generate the closure of state i */

    intptr_t c;
    intptr_t ch;
    int32_t work;
    int32_t k;
    struct wset *u;
    struct wset *v;
    const intptr_t *pi;
    intptr_t *const *s;
    intptr_t *const *t;
    const struct item *q;
    const struct item *p;

    ++zzclose;

    /* first, copy kernel of state i to wsets */

    cwp = wsets;
    ITMLOOP (i, p, q)
    {
        cwp->pitem = p->pitem;
        cwp->flag = 1; /* this item must get closed */
        SETLOOP (k)
        cwp->ws.lset[k] = p->look->lset[k];

        cwp++;
    }

    /* now, go through the loop, closing each item */

    work = 1;
    while (work)
    {
        work = 0;
        WSLOOP (wsets, u)
        {
            if (u->flag == 0)
                continue;
            c = *(u->pitem); /* dot is before c */

            if (c < NTBASE)
            {
                u->flag = 0;
                continue; /* only interesting case is where . is
                           before nonterminal */
            }

            /* compute the lookahead */
            aryfil (clset.lset, tbitset, 0);

            /* find items involving c */
            WSLOOP (u, v)
            {
                if (v->flag == 1 && *(pi = v->pitem) == c)
                {
                    v->flag = 0;
                    if (nolook)
                        continue;
                    while ((ch = *++pi) > 0)
                    {
                        if (ch < NTBASE)
                        {
                            /* terminal symbol */
                            SETBIT (clset.lset, (uint32_t) ch); /*lint !e661 !e662 */
                            break;
                        }
                        /* nonterminal symbol */
                        setunion (clset.lset, pfirst[ch - NTBASE]->lset);
                        if (!pempty[ch - NTBASE])
                            break;
                    }
                    if (ch <= 0)
                        setunion (clset.lset, v->ws.lset);
                }
            }

            /* now loop over productions derived from c */

            c -= NTBASE; /* c is now nonterminal number */

            t = pres[c + 1];
            for (s = pres[c]; s < t; ++s)
            {
                /* put these items into the closure */
                WSLOOP (wsets, v)
                {
                    /* is the item there */
                    if (v->pitem == *s)
                    {
                        /* yes, it is there */
                        if (nolook)
                            goto nexts;
                        if (setunion (v->ws.lset, clset.lset))
                            v->flag = work = 1;
                        goto nexts;
                    }
                }

                /* not there; make a new entry */
                if ((cwp - wsets) + 1 >= WSETSIZE)
                    error ("working set overflow", NULL);
                cwp->pitem = *s;
                cwp->flag = 1;
                if (!nolook)
                {
                    work = 1;
                    SETLOOP (k) cwp->ws.lset[k] = clset.lset[k];
                }
                cwp++;
            nexts:;
            }
        }
    }

    /* have computed closure; flags are reset; return */

    if (cwp > zzcwp)
        zzcwp = cwp;

#if defined(debug)
    if (foutput != NULL)
    {
        yprintf (foutput, "\nState %d, nolook = %d\n", i, nolook);
        WSLOOP (wsets, u)
        {
            if (u->flag)
                yprintf (foutput, "flag set!\n");
            u->flag = 0;
            yprintf (foutput, "\t%s", writem (u->pitem));
            prlook (&u->ws);
            yprintf (foutput, "\n");
        }
    }
#endif
}

static void cpfir (void)
{
    /* compute an array with the first of nonterminals */
    int32_t i;
    intptr_t ch;
    int32_t changes;
    const intptr_t *p;
    intptr_t *const *s;
    intptr_t *const *t;

    zzcwp = &wsets[nnonter];
    NTLOOP (i)
    {
        aryfil (wsets[i].ws.lset, tbitset, 0);
        t = pres[i + 1];
        for (s = pres[i]; s < t; ++s)
        {
            /* initially fill the sets */
            for (p = *s; (ch = *p) > 0; ++p)
            {
                if (ch < NTBASE)
                {
                    SETBIT (wsets[i].ws.lset, (uint32_t) ch); /*lint !e661 !e662 */
                    break;
                }

                if (!pempty[ch - NTBASE])
                    break;
            }
        }
    }

    /* now, reflect transitivity */

    changes = 1;
    while (changes)
    {
        changes = 0;
        NTLOOP (i)
        {
            t = pres[i + 1];
            for (s = pres[i]; s < t; ++s)
            {
                for (p = *s; (ch = (*p - NTBASE)) >= 0; ++p)
                {
                    changes |= setunion (wsets[i].ws.lset, wsets[ch].ws.lset);
                    if (!pempty[ch])
                        break;
                }
            }
        }
    }

    NTLOOP (i) pfirst[i] = flset (&wsets[i].ws);
#if defined(debug)
    if ((foutput != NULL))
    {
        NTLOOP (i)
        {
            yprintf (foutput, "\n%s: ", nontrst[i].name);
            prlook (pfirst[i]);
            yprintf (foutput, " %d\n", pempty[i]);
        }
    }
#endif
}

static void cpres (void)
{
    /* compute an array with the beginnings of productions yielding given
     nonterminals The array pres points to these lists */

    /* the array pyield has the lists: the total size is only NPROD+1 */

    int32_t c;
    int32_t i;
    int32_t j;
    intptr_t **pp;

    static intptr_t *pyield[NPROD]; /*lint !e956 */

    pp = pyield;

    NTLOOP (i)
    {
        c = i + NTBASE;
        pres[i] = pp;
        PLOOP (0, j)
        {
            if (*prdptr[j] == c)
                *pp++ = prdptr[j] + 1;
        }

        if (pres[i] == pp)
            warn ("nonterminal %s not defined!", nontrst[i].name);
    }

    pres[i] = pp;
    if (nerrors)
    {
        summary ();
        exit (EX_ERR);
    }

    if (pp != &pyield[nprod])
    {
        i = (int32_t) (pp - &pyield[nprod]);
        error ("internal Yacc error: pyield %d", &i);
    }
}

static struct looksets *flset (const struct looksets *p)
{
    /* decide if the lookahead set pointed to by p is known */
    /* return pointer to a perminent location for the set */

    int32_t j;
    const intptr_t *w;
    const intptr_t *u;
    const intptr_t *v;
    struct looksets *q;

    for (q = &lkst[nlset]; q-- > lkst;)
    {
        u = p->lset;
        v = q->lset;
        w = &v[tbitset];
        while (v < w)
        {
            if (*u++ != *v++)
                goto more;
        }

        /* we have matched */
        return q;
    more:;
    }
    /* add a new one */
    q = &lkst[nlset++];
    if (nlset >= LSETSIZE)
        error ("too many lookahead sets", NULL);

    SETLOOP (j)
    q->lset[j] = p->lset[j];

    return q;
}

static void gin (int32_t i)
{
    intptr_t *p;
    const intptr_t *r;
    intptr_t *s;
    const intptr_t *q1;
    const intptr_t *q2;

    /* enter gotos on nonterminal i into array a */
    ggreed[i] = 0;

    q2 = mem0 + yypgo[i + 1] - 1;
    q1 = mem0 + yypgo[i];

    /* now, find a place for it */
    for (p = a; p <= &a[ACTSIZE - 1]; ++p)
    {
        if (*p)
            continue;

        for (r = q1; r < q2; r += 2)
        {
            s = p + *r + 1;
            if (*s)
                break;

            if (s > maxa)
            {
                if ((maxa = s) > &a[ACTSIZE - 1])
                    error ("a array overflow", NULL);
            }
        }

        if (r < q2)
            continue;

        /* we have found a spot */
        *p = *q2;
        if (p > maxa)
        {
            if ((maxa = p) > &a[ACTSIZE - 1])
                error ("a array overflow", NULL);
        }

        for (r = q1; r < q2; r += 2)
        {
            s = p + *r + 1;
            *s = r[1];
        }

        pgo[i] = (int32_t) (p - a);
        if (adb > 1)
            yprintf (ftable, "Nonterminal %d, entry at %d\n", i, pgo[i]);

        return;
    }

    error ("cannot place goto %d\n", &i);
}

static void go2gen (int32_t c)
{
    /* output the gotos for nonterminal c */

    int32_t i;
    int32_t work;
    intptr_t cc;
    const struct item *p;
    const struct item *q;

    /* first, find nonterminals with gotos on c */
    aryfil (temp1, nnonter + 1, 0);
    temp1[c] = 1;

    work = 1;
    while (work)
    {
        work = 0;
        PLOOP (0, i)
        {
            if ((cc = prdptr[i][1] - NTBASE) >= 0)
            {
                /* cc is a nonterminal */
                if (temp1[cc] != 0)
                {
                    /* cc has a goto on c */
                    cc = *prdptr[i] - NTBASE; /* thus, the left side of
                                               production i does too */
                    if (temp1[cc] == 0)
                    {
                        work = 1;
                        temp1[cc] = 1;
                    }
                }
            }
        }
    }

    /* now, we have temp1[c] = 1 if a goto on c in closure of cc */

#if defined(debug)
    if (foutput != NULL)
    {
        yprintf (foutput, "%s: gotos on ", nontrst[c].name);
        NTLOOP (i) if (temp1[i]) yprintf (foutput, "%s ", nontrst[i].name);
        yprintf (foutput, "\n");
    }
#endif
    /* now, go through and put gotos into tystate */

    aryfil (tystate, nstate, 0);
    SLOOP (i)
    {
        ITMLOOP (i, p, q)
        {
            if ((cc = *p->pitem) >= NTBASE)
            {
                if (temp1[cc -= NTBASE])
                {
                    /* goto on c is possible */
                    tystate[i] = amem[indgo[i] + c];
                    break;
                }
            }
        }
    }
}

static void go2out (void)
{
    /* output the gotos for the nontermninals */
    int32_t i;
    int32_t j;
    int32_t k;
    intptr_t best;
    int32_t count;
    intptr_t cbest;
    int32_t times;

    fprintf (ftemp, "$\n"); /* mark begining of gotos */

    for (i = 1; i <= nnonter; ++i)
    {
        go2gen (i);

        /* find the best one to make default */
        best = -1;
        times = 0;

        for (j = 0; j <= nstate; ++j)
        {
            /* is j the most frequent */
            if (tystate[j] == 0 || tystate[j] == best)
                continue;

            /* is tystate[j] the most frequent */
            count = 0;
            cbest = tystate[j];

            for (k = j; k <= nstate; ++k)
            {
                if (tystate[k] == cbest)
                    ++count;
            }

            if (count > times)
            {
                best = cbest;
                times = count;
            }
        }

        /* best is now the default entry */

        zzgobest += (times - 1);
        for (j = 0; j <= nstate; ++j)
        {
            if (tystate[j] != 0 && tystate[j] != best)
            {
                fprintf (ftemp, "%d," INTPTRSPEC ",", j, tystate[j]);
                zzgoent += 1;
            }
        }

        /* now, the default */
        zzgoent += 1;
        fprintf (ftemp, INTPTRSPEC "\n", best);
    }
}

static int32_t gtnm (void)
{
    int32_t c;
    intptr_t s;
    intptr_t val;

    /* read and convert an integer from the standard input */
    /* return the terminating character */
    /* blanks, tabs, and newlines are ignored */
    s = 1;
    val = 0;

    while ((c = getc (finput)) != EOF)
    {
        if (isdigit (c))
            val = val * 10 + c - '0';
        else if (c == '-')
            s = -1;
        else if (c != '\r')
            break;
    }

    *pmem++ = s * val;
    if (pmem > &mem0[MEMSIZE - 1])
        error ("out of space", NULL);

    return c;
}

static void hideprod (void)
{
    /* in order to free up the mem and amem arrays for the optimizer, and
     still be able to output yyr1, etc., after the sizes of the action
     array is known, we hide the nonterminals derived by productions in
     levprd. */

    int32_t i;
    int32_t j = 0;

    levprd[0] = 0;
    PLOOP (1, i)
    {
        if (!(levprd[i] & REDFLAG))
        {
            ++j;
            if (foutput != NULL)
                yprintf (foutput, "Rule not reduced:   %s\n", writem (prdptr[i]));
        }

        levprd[i] = *prdptr[i] - NTBASE;
    }

    if (j)
        fprintf (stdout, "%d rules never reduced\n", j);
}

static int32_t nxti (void)
{
    /* finds the next i */
    int32_t i;
    int32_t maxi = -1;
    intptr_t maxval;

    maxval = 0;

    for (i = 1; i <= nnonter; ++i)
    {
        if (ggreed[i] >= maxval)
        {
            maxval = ggreed[i];
            maxi = -i;
        }
    }

    for (i = 0; i < nstate; ++i)
    {
        if (greed[i] >= maxval)
        {
            maxval = greed[i];
            maxi = i;
        }
    }

    if (maxval == 0)
        return NOMORE;

    return maxi;
}

static void osummary (void)
{
    int32_t i;
    const intptr_t *p;

    if (foutput == NULL)
        return;

    i = 0;
    for (p = maxa; p >= a; --p)
    {
        if (*p == 0)
            ++i;
    }

    yprintf (foutput,
             "Optimizer space used: input %d/%d, output %d/%d\n"
             "%d table entries, %d zero\n"
             "maximum spread: %d, maximum offset: %d\n",
             (pmem - mem0) + 1, MEMSIZE, (maxa - a) + 1, ACTSIZE, (maxa - a) + 1, i, maxspr, maxoff);

    fclose (foutput);
}

static void output (void)
{
    /* print the output for the states */
    intptr_t c;
    int32_t i;
    intptr_t k;
    const struct wset *u;
    const struct wset *v;

    yprintf (ftable, "static const int16_t yyexca_%s[] =\n{\n", startnm);

    SLOOP (i)
    {
        /* output the stuff for state i */
        nolook = !(tystate[i] == MUSTLOOKAHEAD);
        closure (i);
        /* output actions */
        nolook = 1;
        aryfil (temp1, ntokens + nnonter + 1, 0);
        WSLOOP (wsets, u)
        {
            c = *(u->pitem);
            if (c > 1 && c < NTBASE && temp1[c] == 0)
            { /*lint !e661 !e662 */
                WSLOOP (u, v)
                {
                    if (c == *(v->pitem))
                        putitem (v->pitem + 1, (struct looksets *) 0);
                }

                temp1[c] = state (c); /*lint !e661 !e662 */
            }
            else if (c > NTBASE && temp1[(c -= NTBASE) + ntokens] == 0)
                temp1[c + ntokens] = amem[indgo[i] + c];
        }

        if (i == 1)
            temp1[1] = ACCEPTCODE;

        /* now, we have the shifts; look at the reductions */

        lastred = 0;
        WSLOOP (wsets, u)
        {
            c = *(u->pitem);
            if (c <= 0)
            {
                /* reduction */
                lastred = -c;
                TLOOP (k)
                {
                    if (BIT (u->ws.lset, k))
                    {
                        if (temp1[k] == 0)
                            temp1[k] = c;
                        else if (temp1[k] < 0)
                        {
                            /* reduce/reduce conflict */
                            if (foutput != NULL)
                                yprintf (foutput, "\n%d: reduce/reduce conflict (red'ns %d and %d ) on %s", i,
                                         -temp1[k], lastred, symnam (k));
                            if (-temp1[k] > lastred)
                                temp1[k] = -lastred;
                            ++zzrrconf;
                        }
                        else
                            /* potential shift/reduce conflict */
                            precftn (lastred, k, i);
                    }
                }
            }
        }

        wract (i);
    }

    yprintf (ftable, "};\n\n");
}

static void precftn (intptr_t r, intptr_t t, int32_t s)
{
    /* decide a shift/reduce conflict by precedence. */
    /* r is a rule number, t a token number */
    /* the conflict is in state s */
    /* temp1[t] is changed to reflect the action */

    int32_t lt;
    int32_t action;
    intptr_t lp;

    lp = levprd[r];
    lt = toklev[t];
    if (PLEVEL (lt) == 0 || PLEVEL (lp) == 0)
    {
        /* conflict */
        if (foutput != NULL)
            yprintf (foutput, "\n%d: shift/reduce conflict (shift %d, red'n %d) on %s", s, temp1[t], r, symnam (t));
        ++zzsrconf;
        return;
    }

    if (PLEVEL (lt) == PLEVEL (lp))
        action = ASSOC (lt);
    else if (PLEVEL (lt) > PLEVEL (lp))
        action = RASC; /* shift */
    else
        action = LASC; /* reduce */

    switch (action)
    {
        case BASC: /* error action */
            temp1[t] = ERRCODE;
            return;

        case LASC: /* reduce */
            temp1[t] = -r;
            return;

        default:
            break;
    }
}

#if defined(debug)
static void prlook (struct looksets *p)
{
    int32_t j;
    int32_t *pp;

    pp = p->lset;
    if (pp == 0)
        yprintf (foutput, "\tNULL");
    else
    {
        yprintf (foutput, " { ");
        TLOOP (j)
        {
            if (BIT (pp, j))
                yprintf (foutput, "%s ", symnam (j));
        }

        yprintf (foutput, "}");
    }
}
#endif

static void putitem (intptr_t *ptr, const struct looksets *lptr)
{
    struct item *j;

    j = pstate[nstate + 1];
    j->pitem = ptr;
    if (!nolook)
        j->look = flset (lptr);

    pstate[nstate + 1] = ++j;
    if ((void *) j > (void *) zzmemsz)
    {
        zzmemsz = (intptr_t *) j;
        if (zzmemsz > &mem0[MEMSIZE - 1])
            error ("out of state space", NULL);
    }
}

static int32_t setunion (intptr_t *aa, const intptr_t *bb)
{
    /* set aa to the union of aa and bb */
    /* return 1 if bb is not aa subset of aa, 0 otherwise */
    int32_t i;
    int32_t sub;
    intptr_t x;

    sub = 0;
    SETLOOP (i)
    {
        *aa = (x = *aa) | *bb++;
        if (*aa++ != x)
            sub = 1;
    }

    return sub;
}

static void stagen (void)
{
    /* generate the states */

#if defined(debug)
    int32_t j;
#endif
    int32_t i;
    intptr_t c;
    struct wset *p;
    struct wset *q;

    /* initialize */

    nstate = 0;
    /* THIS IS FUNNY from the standpoint of portability */
    /* it represents the magic moment when the mem0 array, which has been
     holding the productions, starts to hold item pointers, of a different
     type... */
    /* someday, alloc should be used to allocate all this stuff... for now,
     we accept that if pointers don't fit in integers, there is a
     problem... */

    pstate[0] = pstate[1] = (struct item *) mem;
    aryfil (clset.lset, tbitset, 0);
    putitem (prdptr[0] + 1, &clset);
    tystate[0] = MUSTDO;
    nstate = 1;
    pstate[2] = pstate[1];

    aryfil (amem, ACTSIZE, 0);

    /* now, the main state generation loop */

more:
    SLOOP (i)
    {
        if (tystate[i] != MUSTDO)
            continue;
        tystate[i] = DONE;
        aryfil (temp1, nnonter + 1, 0);
        /* take state i, close it, and do gotos */
        closure (i);
        WSLOOP (wsets, p)
        {
            /* generate goto's */
            if (p->flag)
                continue;
            p->flag = 1;
            c = *(p->pitem);
            if (c <= 1)
            {
                if (pstate[i + 1] - pstate[i] <= p - wsets)
                    tystate[i] = MUSTLOOKAHEAD;
                continue;
            }
            /* do a goto on c */
            WSLOOP (p, q)
            {
                if (c == *(q->pitem))
                {
                    /* this item contributes to the goto */
                    putitem (q->pitem + 1, &q->ws);
                    q->flag = 1;
                }
            }

            if (c < NTBASE)
                state (c); /* register new state */
            else
                temp1[c - NTBASE] = state (c);
        }
#if defined(debug)
        if (foutput != NULL)
        {
            yprintf (foutput, "%d: ", i);
            NTLOOP (j)
            {
                if (temp1[j])
                    yprintf (foutput, "%s %d, ", nontrst[j].name, temp1[j]);
            }
            yprintf (foutput, "\n");
        }
#endif
        indgo[i] = apack (&temp1[1], nnonter - 1) - 1;
        goto more; /* we have done one goto; do some more */
    }
    /* no more to do... stop */
}

static int32_t state (intptr_t c)
{
    /* sorts last state,and sees if it equals earlier ones. returns state
     number */
    int32_t i;
    int32_t s__; /* 01 */
    int32_t *loc;
    intptr_t *s; /* 01 */
    size_t size1;
    size_t size2;
    struct looksets *ss; /* 01 */
    struct item *p1;
    struct item *p2;
    struct item *k;
    struct item *l;
    struct item *q1;
    const struct item *q2;

    p1 = pstate[nstate];
    p2 = pstate[nstate + 1];
    if (p1 == p2)
        return 0; /* null state */

    /* sort the items */
    for (k = p2 - 1; k > p1; k--)
    {
        /* make k the biggest */
        for (l = k - 1; l >= p1; --l)
        {
            if (l->pitem > k->pitem)
            {
                s = k->pitem;
                k->pitem = l->pitem;
                l->pitem = s;
                ss = k->look;
                k->look = l->look;
                l->look = ss;
            }
        }
    }

    size1 = (size_t) (p2 - p1); /* size of state */

    if (c >= NTBASE)
    {
        if (c >= NNONTERM + NTBASE)
            error ("invalid state %d", &c);

        loc = &ntstates[c - NTBASE];
    }
    else
    {
        if (c >= NTERMS)
            error ("invalid state %d", &c);

        loc = &tstates[c];
    }

    for (i = *loc; i != 0; i = mstates[i])
    {
        /* get ith state */
        q1 = pstate[i];
        q2 = pstate[i + 1];
        size2 = (size_t) (q2 - q1);
        if (size1 != size2)
            continue;

        k = p1;
        for (l = q1; l < q2; l++)
        {
            if (l->pitem != k->pitem)
                break;
            ++k;
        }

        if (l != q2)
            continue;

        /* found it */
        pstate[nstate + 1] = pstate[nstate]; /* delete last state */
        /* fix up lookaheads */
        if (nolook)
            return i;

        for (l = q1, k = p1; l < q2; ++l, ++k)
        {
            SETLOOP (s__) clset.lset[s__] = l->look->lset[s__];
            if (setunion (clset.lset, k->look->lset))
            {
                tystate[i] = MUSTDO;
                /* register the new set */
                l->look = flset (&clset);
            }
        }

        return i;
    }

    /* state is new */
    if (nolook)
        error ("yacc state/nolook error", NULL);

    pstate[nstate + 2] = p2;
    if (nstate + 1 >= NSTATES)
        error ("too many states", NULL);

    mstates[nstate] = *loc;
    *loc = nstate;

    tystate[nstate] = MUSTDO;
    return nstate++;
}

static void stin (int32_t i)
{
    char msg[100];
    int32_t j;
    intptr_t n;
    int32_t flag;
    const intptr_t *r;
    intptr_t *s;
    const intptr_t *q1;
    const intptr_t *q2;

    greed[i] = 0;

    /* enter state i into the a array */
    q2 = mem0 + yypact[i + 1];
    q1 = mem0 + yypact[i];

    /* find an acceptable place */
    for (n = -maxoff; n < ACTSIZE; ++n)
    {
        flag = 0;
        for (r = q1; r < q2; r += 2)
        {
            if ((s = *r + a + n) < a)
                break;

            if (*s == 0)
                ++flag;
            else if (*s != r[1])
                break;
        }

        if (r < q2)
            continue;

        /* check that the position equals another only if the states are
         identical */
        for (j = 0; j < nstate; ++j)
        {
            if (pa[j] == n)
            {
                if (flag)
                    break; /* we have some disagreement */

                if (yypact[j + 1] + yypact[i] == yypact[j] + yypact[i + 1])
                {
                    /* states are equal */
                    pa[i] = n;
                    if (adb > 1)
                        yprintf (ftable, "State %d: entry at %d equals state %d\n", i, n, j);
                    return;
                }

                break; /* we have some disagreement */
            }
        }

        if (j < nstate)
            continue;

        for (r = q1; r < q2; r += 2)
        {
            if ((s = *r + n + a) > &a[ACTSIZE - 1])
                error ("out of space in optimizer a array", NULL);

            if (s > maxa)
                maxa = s;

            if (*s != 0 && *s != r[1])
            {
                sprintf (msg, "clobber of a array, pos'n " PTRDIFFSPEC ", by " INTPTRSPEC, s - a, r[1]);
                error (msg, NULL);
            }

            *s = r[1];
        }

        pa[i] = n;
        if (adb > 1)
            yprintf (ftable, "State %d: entry at %d\n", i, pa[i]);

        return;
    }

    error ("Error; failure to place state %d\n", &i);
}

static const char *symnam (intptr_t i)
{
    /* return a pointer to the name of symbol i */
    const char *cp;

    if (i < NTERMS)
    {
        cp = tokset[i].name;
    }
    else if (i >= NTBASE && i < NTBASE + NNONTERM)
    {
        cp = nontrst[i - NTBASE].name;
    }
    else
    {
        cp = "<invalid>";
    }

    if (*cp == ' ')
        ++cp;

    return cp;
}

static void wract (int32_t i)
{
    /* output state i */
    /* temp1 has the actions, lastred the default */
    int32_t p;
    int32_t p0;
    intptr_t p1;
    int32_t ntimes;
    intptr_t tred;
    int32_t count;
    int32_t j;
    int32_t flag;

    /* find the best choice for lastred */

    lastred = 0;
    ntimes = 0;
    TLOOP (j)
    {
        if (temp1[j] >= 0)
            continue;
        if (temp1[j] + lastred == 0)
            continue;
        /* count the number of appearances of temp1[j] */
        count = 0;
        tred = -temp1[j];
        levprd[tred] |= REDFLAG;
        TLOOP (p)
        {
            if (temp1[p] + tred == 0)
                ++count;
        }
        if (count > ntimes)
        {
            lastred = tred;
            ntimes = count;
        }
    }

    /* for error recovery, arrange that, if there is a shift on the error
     recovery token, `error', that the default be the error action */
    if (temp1[1] > 0)
        lastred = 0;

    /* clear out entries in temp1 which equal lastred */
    TLOOP (p) if (temp1[p] + lastred == 0) temp1[p] = 0;

    wrstate (i);
    defact[i] = lastred;

    flag = 0;
    TLOOP (p0)
    {
        if ((p1 = temp1[p0]) != 0)
        {
            if (p1 < 0)
            {
                p1 = -p1;
                goto exc;
            }
            else if (p1 == ACCEPTCODE)
            {
                p1 = -1;
                goto exc;
            }
            else if (p1 == ERRCODE)
            {
                p1 = 0;
                goto exc;
            exc:
                if (flag++ == 0)
                    yprintf (ftable, "\t-1, %d,\n", i);
                yprintf (ftable, "\t%d, %d,\n", tokset[p0].value, p1);
                ++zzexcp;
            }
            else
            {
                fprintf (ftemp, "%d," INTPTRSPEC ",", tokset[p0].value, p1);
                ++zzacent;
            }
        }
    }
    if (flag)
    {
        defact[i] = -2;
        yprintf (ftable, "\t-2, %d,\n", lastred);
    }

    fprintf (ftemp, "\n");
}

static char *writem (const intptr_t *pp)
{
    /* creates output string for item pointed to by pp */
    intptr_t i;
    const intptr_t *p;
    char *q;

    for (p = pp; *p > 0; ++p)
        ;

    p = prdptr[-*p];
    q = chcopy (sarr, nontrst[*p - NTBASE].name);
    q = chcopy (q, " : ");

    for (;;)
    {
        *q++ = (char) (++p == pp ? '_' : ' ');
        *q = '\0';
        if ((i = *p) <= 0)
            break;
        q = chcopy (q, symnam (i));
        if (q > &sarr[ISIZE - 30])
            error ("item too big", NULL);
    }

    if ((i = *pp) < 0)
    {
        /* an item calling for a reduction */
        q = chcopy (q, "    (");
        sprintf (q, INTPTRSPEC ")", -i);
    }

    return sarr;
}

static void wrstate (int32_t i)
{
    /* writes state i */
    intptr_t j0;
    intptr_t j1;
    const struct item *pp;
    const struct item *qq;
    const struct wset *u;

    if (foutput == NULL)
        return;

    yprintf (foutput, "\nstate %d\n", i);
    ITMLOOP (i, pp, qq)
    yprintf (foutput, "\t%s\n", writem (pp->pitem));
    if (tystate[i] == MUSTLOOKAHEAD)
    {
        /* print out empty productions in closure */
        WSLOOP (wsets + (pstate[i + 1] - pstate[i]), u)
        {
            if (*(u->pitem) < 0)
                yprintf (foutput, "\t%s\n", writem (u->pitem));
        }
    }

    /* check for state equal to another */

    TLOOP (j0) if ((j1 = temp1[j0]) != 0)
    {
        yprintf (foutput, "\n\t%s  ", symnam (j0));
        if (j1 > 0)
        {
            /* shift, error, or accept */
            if (j1 == ACCEPTCODE)
                yprintf (foutput, "accept");
            else if (j1 == ERRCODE)
                yprintf (foutput, "error");
            else
                yprintf (foutput, "shift %d", j1);
        }
        else
            yprintf (foutput, "reduce %d", -j1);
    }

    /* output the final production */

    if (lastred)
        yprintf (foutput, "\n\t.  reduce %d\n\n", lastred);
    else
        yprintf (foutput, "\n\t.  error\n\n");

    /* now, output nonterminal actions */
    j1 = ntokens;
    for (j0 = 1; j0 <= nnonter; ++j0)
    {
        if (temp1[++j1])
            yprintf (foutput, "\t%s  goto %d\n", symnam (j0 + NTBASE), temp1[j1]);
    }
}

/* =======================================================================
 RDMYacc main program
 */
int32_t main (int32_t argc, const char *const argv[])
{
    pgo = wsets[0].ws.lset;
    ggreed = lkst[0].lset;

    setup (argc, argv); /* initialize and read productions */
    tbitset = NWORDS (ntokens);
    cpres ();  /* make table of which productions yield a
                given nonterminal */
    cempty (); /* make a table of which nonterminals can
                match the empty string */
    cpfir ();  /* make a table of firsts of nonterminals */
    stagen (); /* generate the states */
    output (); /* write the states and the tables */
    go2out ();
    hideprod ();
    summary ();
    callopt ();
    others ();

    return (0);
}
